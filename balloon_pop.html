<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Balloon Pop Simulation</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #222;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 1px solid white;
            background: linear-gradient(to bottom, #87CEEB 0%, #E0F6FF 100%);
            cursor: none;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
        #stats {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 18px;
        }
        button {
            padding: 8px 15px;
            margin: 5px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background: #4CAF50;
            color: white;
            font-weight: bold;
        }
        button:hover {
            background: #45a049;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button onclick="resetSimulation()">Reset (R)</button>
        <div style="margin-top: 5px; font-size: 12px;">Move the mouse to control the needle.</div>
        <div style="font-size: 12px;">Click or press any key to enable sound.</div>
    </div>
    <div id="stats">
        Popped: <span id="poppedCount">0</span> / <span id="totalCount">20</span><br>
        Time: <span id="timer">0.0</span>s
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script>
        // Matter.js setup
        const { Engine, Render, World, Bodies, Body, Constraint, Events, Vector } = Matter;
        const engine = Engine.create();
        engine.gravity.y = -0.3; // Negative gravity makes balloons float up

        const canvas = document.createElement('canvas');
        canvas.width = 800;
        canvas.height = 600;
        document.body.appendChild(canvas);

        const render = Render.create({
            canvas: canvas,
            engine: engine,
            options: {
                width: 800,
                height: 600,
                wireframes: false,
                background: 'transparent'
            }
        });

        // Balloon colors
        const colors = ['#FF6B6B', '#4ECDC4', '#FFE66D', '#95E1D3', '#FF8FB1', '#FFA07A', '#9B59B6', '#3498DB'];

        // Game state
        let balloons = [];
        let strings = [];
        let needle;
        let poppedCount = 0;
        let totalBalloons = 20;
        let gameCompleted = false;
        let particles = []; // Array to hold explosion particles

        // Timer state
        let timerStartTime = null;
        let timerElapsed = 0;
        let timerRunning = false;
        let finalTime = 0;

        // Audio context for sound effects
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // Particle class for explosion effects
        class Particle {
            constructor(x, y, balloonColor, balloonVelocity, balloonSize) {
                this.x = x;
                this.y = y;

                // Random angle for radial burst
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 6 + 2; // 2-8px per frame

                // Inherit balloon velocity and add explosion force
                this.vx = (balloonVelocity ? balloonVelocity.x : 0) + Math.cos(angle) * speed;
                this.vy = (balloonVelocity ? balloonVelocity.y : 0) + Math.sin(angle) * speed;

                // Gravity and air resistance
                this.gravity = 0.15;
                this.drag = 0.98;

                // Visual properties
                this.color = balloonColor;
                this.alpha = 1.0;
                this.fadeRate = Math.random() * 0.015 + 0.01; // 0.01-0.025

                // Size variation - smaller particles for smaller balloons
                this.size = Math.random() * (balloonSize * 0.15) + (balloonSize * 0.1); // 10-25% of balloon size

                // Rotation for confetti effect
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.3; // -0.15 to 0.15 rad/frame

                // Particle type (confetti, sparkle, or rubber fragment)
                const rand = Math.random();
                if (rand < 0.6) {
                    this.particleType = 'confetti'; // 60% confetti
                } else if (rand < 0.85) {
                    this.particleType = 'sparkle'; // 25% sparkles
                } else {
                    this.particleType = 'rubber'; // 15% rubber fragments
                }
            }

            update() {
                // Apply physics
                this.vy += this.gravity;
                this.vx *= this.drag;
                this.vy *= this.drag;

                // Update position
                this.x += this.vx;
                this.y += this.vy;

                // Update rotation
                this.rotation += this.rotationSpeed;

                // Fade out
                this.alpha -= this.fadeRate;
            }

            draw(ctx) {
                if (this.alpha <= 0) return;

                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                if (this.particleType === 'confetti') {
                    // Rectangular confetti
                    ctx.fillStyle = this.color;
                    ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size * 1.5);
                } else if (this.particleType === 'sparkle') {
                    // Star-shaped sparkles
                    ctx.fillStyle = lightenColor(this.color, 50);
                    ctx.beginPath();
                    for (let i = 0; i < 4; i++) {
                        const angle = (Math.PI / 2) * i;
                        const r = i % 2 === 0 ? this.size : this.size * 0.4;
                        const px = Math.cos(angle) * r;
                        const py = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                } else {
                    // Irregular rubber fragments
                    ctx.fillStyle = darkenColor(this.color, 20);
                    ctx.beginPath();
                    ctx.ellipse(0, 0, this.size, this.size * 0.7, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }

            isDead() {
                return this.alpha <= 0 || this.y > 650; // Off screen or faded
            }
        }

        function playPopSound(frequency = 400) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.value = frequency;
            oscillator.type = 'sine';

            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }

        // Create a balloon with string
        function createBalloon(x, y) {
            const size = Math.random() * 20 + 20; // 20-40px radius
            const color = colors[Math.floor(Math.random() * colors.length)];

            const balloon = Bodies.circle(x, y, size, {
                density: 0.001,
                friction: 0.05,
                frictionAir: 0.01,
                restitution: 0.6,
                render: {
                    visible: false // Custom rendering below
                }
            });

            // Anchor point at bottom
            const anchor = Bodies.circle(x, 590, 2, {
                isStatic: true,
                render: { fillStyle: '#333' }
            });

            // String connecting balloon to anchor
            const string = Constraint.create({
                bodyA: balloon,
                bodyB: anchor,
                length: Math.random() * 200 + 150, // 150-350px string length
                stiffness: 0.1,
                render: {
                    strokeStyle: '#333',
                    lineWidth: 2
                }
            });

            balloon.size = size; // Store size for sound frequency
            balloon.color = color; // Store color for custom rendering
            balloon.isPopped = false;

            return { balloon, string, anchor };
        }

        // Create needle (syringe-style with custom rendering)
        function createNeedle() {
            // Single body for collision detection (invisible)
            needle = Bodies.rectangle(400, 300, 3, 50, {
                density: 0.01,
                render: {
                    visible: false // We'll draw custom syringe
                }
            });
            Body.setStatic(needle, true);
            World.add(engine.world, needle);
        }

        // Custom rendering for syringe
        Events.on(render, 'afterRender', () => {
            if (!needle) return;

            const ctx = render.context;
            const pos = needle.position;
            const angle = needle.angle;

            ctx.save();
            ctx.translate(pos.x, pos.y);
            ctx.rotate(angle);

            // Draw needle tip (sharp, gray)
            ctx.fillStyle = '#A9A9A9';
            ctx.fillRect(-1, -25, 2, 25);

            // Draw barrel (transparent with outline)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 1.5;
            ctx.fillRect(-4, 0, 8, 20);
            ctx.strokeRect(-4, 0, 8, 20);

            // Draw plunger (red cap at back)
            ctx.fillStyle = '#FF6B6B';
            ctx.fillRect(-3, 20, 6, 5);

            ctx.restore();

            // Draw realistic balloons
            for (const balloon of balloons) {
                if (balloon.isPopped) continue;

                const pos = balloon.position;
                const size = balloon.size;
                const color = balloon.color;

                ctx.save();
                ctx.translate(pos.x, pos.y);

                // Draw balloon body with gradient (3D effect)
                const gradient = ctx.createRadialGradient(
                    -size * 0.3, -size * 0.3, size * 0.1,
                    0, 0, size
                );

                // Lighter at top-left, darker at edges for 3D effect
                gradient.addColorStop(0, lightenColor(color, 40));
                gradient.addColorStop(0.5, color);
                gradient.addColorStop(1, darkenColor(color, 30));

                // Draw balloon shape (slightly oval, wider at top)
                ctx.beginPath();
                ctx.ellipse(0, 0, size * 0.95, size, 0, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();

                // Add highlight for shine effect
                ctx.beginPath();
                ctx.ellipse(-size * 0.3, -size * 0.35, size * 0.25, size * 0.35, -0.3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.fill();

                // Draw knot at bottom
                ctx.beginPath();
                ctx.ellipse(0, size + 3, 4, 6, 0, 0, Math.PI * 2);
                ctx.fillStyle = darkenColor(color, 40);
                ctx.fill();

                ctx.restore();
            }

            // Draw particles (after balloons, before needle)
            for (const particle of particles) {
                particle.draw(ctx);
            }
        });

        // Helper functions for color manipulation
        function lightenColor(color, percent) {
            const num = parseInt(color.replace("#",""), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.min(255, (num >> 16) + amt);
            const G = Math.min(255, (num >> 8 & 0x00FF) + amt);
            const B = Math.min(255, (num & 0x0000FF) + amt);
            return `rgb(${R},${G},${B})`;
        }

        function darkenColor(color, percent) {
            const num = parseInt(color.replace("#",""), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.max(0, (num >> 16) - amt);
            const G = Math.max(0, (num >> 8 & 0x00FF) - amt);
            const B = Math.max(0, (num & 0x0000FF) - amt);
            return `rgb(${R},${G},${B})`;
        }

        // Initialize balloons
        function initBalloons() {
            balloons = [];
            strings = [];

            for (let i = 0; i < totalBalloons; i++) {
                const x = Math.random() * 700 + 50;
                const y = Math.random() * 400 + 100;
                const { balloon, string, anchor } = createBalloon(x, y);

                balloons.push(balloon);
                strings.push(string);
                World.add(engine.world, [balloon, anchor, string]);
            }
        }

        // Pop balloon with explosion effect
        function popBalloon(balloon) {
            if (balloon.isPopped) return;

            balloon.isPopped = true;
            poppedCount++;
            document.getElementById('poppedCount').textContent = poppedCount;

            // Start timer on first balloon pop
            if (poppedCount === 1 && !timerRunning) {
                timerStartTime = Date.now();
                timerRunning = true;
            }

            // Play pop sound (higher pitch for smaller balloons)
            const frequency = 600 - (balloon.size * 5);
            playPopSound(frequency);

            // Create particle explosion
            const particleCount = Math.floor(Math.random() * 30 + 20); // 20-50 particles
            for (let i = 0; i < particleCount; i++) {
                particles.push(new Particle(
                    balloon.position.x,
                    balloon.position.y,
                    balloon.color,
                    balloon.velocity,
                    balloon.size
                ));
            }

            // Apply shockwave to nearby balloons
            const shockwaveRadius = 150;
            const shockwaveForce = 0.05;

            for (const otherBalloon of balloons) {
                if (otherBalloon === balloon || otherBalloon.isPopped) continue;

                const distance = Vector.magnitude(
                    Vector.sub(otherBalloon.position, balloon.position)
                );

                if (distance < shockwaveRadius) {
                    const direction = Vector.normalise(
                        Vector.sub(otherBalloon.position, balloon.position)
                    );
                    const forceMagnitude = shockwaveForce * (1 - distance / shockwaveRadius);
                    const force = Vector.mult(direction, forceMagnitude);
                    Body.applyForce(otherBalloon, otherBalloon.position, force);
                }
            }

            // Remove balloon from world
            World.remove(engine.world, balloon);

            // Find and remove associated string
            const index = balloons.indexOf(balloon);
            if (index > -1 && strings[index]) {
                World.remove(engine.world, strings[index]);
            }
        }

        // Mouse tracking for needle
        let mousePos = { x: 400, y: 300 };
        let lastMousePos = { x: 400, y: 300 };

        canvas.addEventListener('mousedown', () => {
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }, { once: true }); // Use 'once' to only fire this event once

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            lastMousePos = { ...mousePos };
            mousePos = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        });

        // Smooth angle interpolation helper
        function lerpAngle(from, to, t) {
            let diff = to - from;
            // Handle angle wrapping (shortest path)
            while (diff > Math.PI) diff -= Math.PI * 2;
            while (diff < -Math.PI) diff += Math.PI * 2;
            return from + diff * t;
        }

        // Update needle position and rotation
        Events.on(engine, 'beforeUpdate', () => {
            if (needle) {
                // Calculate target angle from movement direction
                const dx = mousePos.x - lastMousePos.x;
                const dy = mousePos.y - lastMousePos.y;

                // Only update target angle if there's significant movement
                if (Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5) {
                    const targetAngle = Math.atan2(dy, dx) + Math.PI / 2;

                    // Smooth rotation with interpolation
                    const currentAngle = needle.angle;
                    const smoothAngle = lerpAngle(currentAngle, targetAngle, 0.2);
                    Body.setAngle(needle, smoothAngle);
                }

                // Update position after angle calculation
                Body.setPosition(needle, mousePos);
            }

            // Update timer display
            if (timerRunning) {
                timerElapsed = (Date.now() - timerStartTime) / 1000;
                document.getElementById('timer').textContent = timerElapsed.toFixed(1);
            }

            // Update particles
            for (const particle of particles) {
                particle.update();
            }

            // Remove dead particles
            particles = particles.filter(particle => !particle.isDead());
        });

        // Collision detection for popping
        Events.on(engine, 'collisionStart', (event) => {
            for (const pair of event.pairs) {
                const { bodyA, bodyB } = pair;

                if (bodyA === needle && balloons.includes(bodyB)) {
                    popBalloon(bodyB);
                } else if (bodyB === needle && balloons.includes(bodyA)) {
                    popBalloon(bodyA);
                }
            }
        });

        // Reset simulation
        function resetSimulation() {
            World.clear(engine.world);
            Engine.clear(engine);
            poppedCount = 0;
            gameCompleted = false;
            particles = []; // Clear all particles
            document.getElementById('poppedCount').textContent = poppedCount;

            // Reset timer
            timerStartTime = null;
            timerElapsed = 0;
            timerRunning = false;
            finalTime = 0;
            document.getElementById('timer').textContent = '0.0';

            initBalloons();
            createNeedle();
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'r' || e.key === 'R') {
                resetSimulation();
            }
        });

        // Check if all balloons are popped
        Events.on(engine, 'afterUpdate', () => {
            const activeBalloonsCount = balloons.filter(b => !b.isPopped).length;
            if (activeBalloonsCount === 0 && poppedCount > 0 && !gameCompleted) {
                gameCompleted = true;

                // Stop timer and save final time
                if (timerRunning) {
                    timerRunning = false;
                    finalTime = timerElapsed;
                }

                setTimeout(() => {
                    if (confirm(`All balloons popped in ${finalTime.toFixed(1)}s! Play again?`)) {
                        resetSimulation();
                    }
                }, 500);
            }
        });

        // Start simulation
        initBalloons();
        createNeedle();
        Render.run(render);
        const runner = Matter.Runner.create();
        Matter.Runner.run(runner, engine);

        console.log('Balloon Pop Simulation Ready! Move mouse to control needle.');
    </script>
</body>
</html>
