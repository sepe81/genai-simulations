<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High Voltage Battery Box</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #050505;
            color: #eee;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            z-index: 100;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            backdrop-filter: blur(5px);
        }
        h2 {
            margin: 0 0 10px 0;
            color: #ffcc00;
            text-shadow: 0 0 10px rgba(255, 204, 0, 0.5);
        }
        p {
            margin: 0;
            color: #ccc;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div id="info">
        <h2>âš  High Voltage Box</h2>
        <p>Drag the battery to generate arcs.</p>
        <p>Lightning seeks the mouse pointer and ground.</p>
        <p style="margin-top: 5px; color: #aaa;">'S' - Spawn Golem | 'F' - Fireworks | 'O' - Toggle Arcs | 'R' - Reset</p>
    </div>

    <!-- Matter.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

    <script>
        let lightningEnabled = true;

        const Engine = Matter.Engine,
              Render = Matter.Render,
              Runner = Matter.Runner,
              Bodies = Matter.Bodies,
              Composite = Matter.Composite,
              Mouse = Matter.Mouse,
              MouseConstraint = Matter.MouseConstraint,
              Events = Matter.Events,
              Vector = Matter.Vector,
              Body = Matter.Body;

        // --- Engine Setup ---
        const engine = Engine.create({
            enableSleeping: true,
            positionIterations: 10,
            velocityIterations: 8
        });
        const world = engine.world;

        const render = Render.create({
            element: document.body,
            engine: engine,
            options: {
                width: globalThis.innerWidth,
                height: globalThis.innerHeight,
                wireframes: false,
                background: '#050505',
                pixelRatio: globalThis.devicePixelRatio
            }
        });

        // --- Golem Logic ---
        let golems = [];

        function spawnIronGolem() {
            const x = globalThis.innerWidth / 2 + (Math.random() - 0.5) * 200;
            const y = -150;
            const scale = 1.0;

            // Dimensions (approximate Minecraft proportions)
            // Head: 8x8x8 -> 32x32
            // Body: 18x12x? -> 72x48
            // Arms: 4x30x? -> 16x120
            // Legs: 6x16x? -> 24x64

            const group = Body.nextGroup(true);
            const renderStyle = { fillStyle: '#e0e0e0', strokeStyle: '#999', lineWidth: 1 };

            // Head
            const head = Bodies.rectangle(x, y - 60 * scale, 32 * scale, 32 * scale, {
                render: { ...renderStyle, fillStyle: '#f0f0f0' },
                collisionFilter: { group: group }
            });
            // Torso (Main body)
            const torso = Bodies.rectangle(x, y, 72 * scale, 50 * scale, {
                render: { ...renderStyle, fillStyle: '#d0d0d0' },
                collisionFilter: { group: group }
            });
            // Hips/Lower Body
            const hips = Bodies.rectangle(x, y + 35 * scale, 40 * scale, 20 * scale, {
                render: renderStyle,
                collisionFilter: { group: group }
            });

            // Arms (Long, hanging)
            const armW = 16 * scale;
            const armH = 90 * scale;
            const leftArm = Bodies.rectangle(x - 55 * scale, y + 10 * scale, armW, armH, {
                render: renderStyle,
                collisionFilter: { group: group }
            });
            const rightArm = Bodies.rectangle(x + 55 * scale, y + 10 * scale, armW, armH, {
                render: renderStyle,
                collisionFilter: { group: group }
            });

            // Legs
            const legW = 20 * scale;
            const legH = 50 * scale;
            const leftLeg = Bodies.rectangle(x - 15 * scale, y + 70 * scale, legW, legH, {
                render: renderStyle,
                collisionFilter: { group: group }
            });
            const rightLeg = Bodies.rectangle(x + 15 * scale, y + 70 * scale, legW, legH, {
                render: renderStyle,
                collisionFilter: { group: group }
            });

            // Assemble the golem
            const golem = Body.create({
                parts: [head, torso, hips, leftArm, rightArm, leftLeg, rightLeg],
                restitution: 0.05,   // Slight bounce is better for stability than 0
                friction: 0.6,       // High but not 'glue'
                frictionStatic: 1.0, // Standard high static friction
                frictionAir: 0.02,
                density: 0.1         // Heavy
            });

            // Make it very hard to rotate (stabilize stacking)
            Body.setInertia(golem, golem.inertia * 10);

            Composite.add(world, golem);
            golems.push(golem);

            // Clean up golems that fall off screen
            if (golems.length > 5) {
                 const oldGolem = golems.shift();
                 Composite.remove(world, oldGolem);
            }
        }

        function resetSimulation() {
            // Remove all golems
            golems.forEach(golem => Composite.remove(world, golem));
            golems = [];

            // Clear fireworks and sparks
            fireworks = [];
            sparks.length = 0; // Clear array efficiently

            // Reset battery position
            Body.setPosition(battery, { x: globalThis.innerWidth / 2, y: globalThis.innerHeight / 3 });
            Body.setAngle(battery, 0);
            Body.setVelocity(battery, { x: 0, y: 0 });
            Body.setAngularVelocity(battery, 0);
        }

        globalThis.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 's') {
                spawnIronGolem();
            } else if (e.key.toLowerCase() === 'f') {
                launchFirework();
            } else if (e.key.toLowerCase() === 'o') {
                lightningEnabled = !lightningEnabled;
            } else if (e.key.toLowerCase() === 'r') {
                resetSimulation();
            }
        });

        // --- Fireworks Logic ---
        let fireworks = [];

        function launchFirework() {
            // Find battery top position (approx)
            const angle = battery.angle;
            // Launch from center top of battery
            const launchPos = Vector.add(battery.position, Vector.rotate({x: 0, y: -40}, angle));
            const velocity = Vector.rotate({x: (Math.random()-0.5)*2, y: -15 - Math.random()*5}, angle);

            fireworks.push({
                pos: launchPos,
                vel: velocity,
                color: `hsl(${Math.random()*360}, 100%, 50%)`,
                life: 60 + Math.random() * 30, // frames until explosion
                type: 'rocket'
            });
        }

        function explodeFirework(fw) {
            const particleCount = 50;
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                fireworks.push({
                    pos: { ...fw.pos },
                    vel: { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed },
                    color: fw.color,
                    life: 40 + Math.random() * 20,
                    decay: 0.015,
                    type: 'particle',
                    gravity: 0.1
                });
            }
            // Sound effect? (optional, browser policy usually blocks auto audio)
        }

        function updateAndDrawFireworks(ctx) {
             ctx.globalCompositeOperation = 'lighter';

             for (let i = fireworks.length - 1; i >= 0; i--) {
                 const fw = fireworks[i];

                 if (fw.type === 'rocket') {
                     fw.pos.x += fw.vel.x;
                     fw.pos.y += fw.vel.y;
                     fw.vel.y += 0.05; // gravity
                     fw.life--;

                     // Trail
                     if (Math.random() < 0.4) {
                         createSpark(fw.pos, {x: (Math.random()-0.5)*2, y: 2}, '#fff');
                     }

                     // Draw Rocket (Wider)
                     ctx.fillStyle = '#ff4400';
                     ctx.strokeStyle = '#fff';
                     ctx.lineWidth = 2;
                     ctx.beginPath();
                     ctx.arc(fw.pos.x, fw.pos.y, 5, 0, Math.PI * 2);
                     ctx.fill();
                     ctx.stroke();

                     // Explode if life ends OR hits top of viewport
                     if (fw.life <= 0 || fw.pos.y <= 15) {
                         explodeFirework(fw);
                         fireworks.splice(i, 1);
                     }
                 } else if (fw.type === 'particle') {
                     fw.pos.x += fw.vel.x;
                     fw.pos.y += fw.vel.y;
                     fw.vel.y += fw.gravity;
                     fw.vel.x *= 0.95; // drag
                     fw.life--;
                     fw.alpha = Math.min(1, fw.life / 30);

                     if (fw.life <= 0) {
                         fireworks.splice(i, 1);
                         continue;
                     }

                     ctx.fillStyle = fw.color; // Simplify color handling
                     ctx.globalAlpha = fw.alpha;
                     ctx.beginPath();
                     ctx.arc(fw.pos.x, fw.pos.y, 2, 0, Math.PI*2);
                     ctx.fill();
                     ctx.globalAlpha = 1.0;
                 }
             }
             ctx.globalCompositeOperation = 'source-over';
        }

        // --- Spark Particle System ---
        const sparks = [];

        function createSpark(position, velocity, color) {
            sparks.push({
                pos: { ...position },
                vel: { ...velocity },
                life: 1.0, // 0 to 1
                decay: 0.02 + Math.random() * 0.03,
                color: color
            });
        }

        function updateAndDrawSparks(ctx) {
            ctx.globalCompositeOperation = 'lighter';
            for (let i = sparks.length - 1; i >= 0; i--) {
                const s = sparks[i];
                s.life -= s.decay;

                // Physics-ish movement
                s.pos.x += s.vel.x;
                s.pos.y += s.vel.y;
                s.vel.y += 0.5; // Gravity
                s.vel.x *= 0.95; // Air resistance

                if (s.life <= 0) {
                    sparks.splice(i, 1);
                    continue;
                }

                ctx.fillStyle = s.color || `rgba(255, 200, 50, ${s.life})`;
                ctx.beginPath();
                ctx.arc(s.pos.x, s.pos.y, 1.5 * s.life, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalCompositeOperation = 'source-over';
        }

        // --- Bodies ---

        // 1. The Battery Box
        const batteryWidth = 120;
        const batteryHeight = 80;
        const battery = Bodies.rectangle(
            globalThis.innerWidth / 2,
            globalThis.innerHeight / 3,
            batteryWidth,
            batteryHeight,
            {
                chamfer: { radius: 10 },
                render: {
                    fillStyle: '#333',
                    strokeStyle: '#fa0',
                    lineWidth: 3
                },
                density: 0.01,
                restitution: 0.2,
                friction: 0.5
            }
        );

        // Ground and walls
        const wallOptions = {
            isStatic: true,
            render: { fillStyle: '#1a1a1a' },
            friction: 0.8
        };
        const ground = Bodies.rectangle(globalThis.innerWidth / 2, globalThis.innerHeight + 30, globalThis.innerWidth, 100, wallOptions);
        const leftWall = Bodies.rectangle(-30, globalThis.innerHeight / 2, 60, globalThis.innerHeight, wallOptions);
        const rightWall = Bodies.rectangle(globalThis.innerWidth + 30, globalThis.innerHeight / 2, 60, globalThis.innerHeight, wallOptions);

        // --- Staircase ---
        const stairs = [];
        const stepHeight = 80;
        const stepWidths = [600, 400, 200];

        stepWidths.forEach((w, i) => {
            // Align left edge to x=0 (approx)
            // Center x = w / 2
            // y = ground top (innerHeight) - half height - (index * height)
            // Ground center y is innerHeight + 50 (height 100). Top is innerHeight.

            stairs.push(Bodies.rectangle(
                w / 2,
                globalThis.innerHeight - (stepHeight/2) - (i * stepHeight),
                w,
                stepHeight,
                { ...wallOptions, label: 'stairs' }
            ));
        });

        Composite.add(world, [battery, ground, leftWall, rightWall, ...stairs]);

        // --- Interaction ---
        const mouse = Mouse.create(render.canvas);
        const mouseConstraint = MouseConstraint.create(engine, {
            mouse: mouse,
            constraint: {
                stiffness: 0.2,
                render: { visible: false }
            }
        });
        Composite.add(world, mouseConstraint);
        render.mouse = mouse;

        // --- Lightning Logic ---

        function generateLightningPoints(start, end, segments = 8, roughness = 0.5) {
            const points = [start];
            const direction = Vector.sub(end, start);
            const length = Vector.magnitude(direction);

            // Recursive midpoint displacement could be better, but iterative jitter is simpler/faster for 60fps
            const normal = Vector.perp(Vector.normalise(direction));

            for (let i = 1; i < segments; i++) {
                const t = i / segments;
                const idealPos = Vector.add(start, Vector.mult(direction, t));

                const jitter = (Math.random() - 0.5) * length * roughness;
                const newPos = Vector.add(idealPos, Vector.mult(normal, jitter));

                points.push(newPos);
            }
            points.push(end);
            return points;
        }

        function drawLightningBranch(ctx, start, end, depth, color) {
            if (depth <= 0) return;

            const dist = Vector.magnitude(Vector.sub(end, start));
            const segments = Math.max(3, Math.floor(dist / 20));
            const points = generateLightningPoints(start, end, segments, 0.4);

            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.stroke();

            // Chance to branch
            if (depth > 1 && Math.random() < 0.4) {
                const midIndex = Math.floor(points.length / 2);
                const midPoint = points[midIndex];

                const mainDir = Vector.sub(end, start);
                const branchAngle = (Math.random() - 0.5) * 1.5; // Radians
                const branchDir = Vector.rotate(mainDir, branchAngle);
                const branchEnd = Vector.add(midPoint, Vector.mult(branchDir, 0.6)); // Shorter branch

                drawLightningBranch(ctx, midPoint, branchEnd, depth - 1, color);
            }
        }

        function drawLightning(ctx, start, end, color = '#bbf') {
            ctx.save();
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.globalCompositeOperation = 'lighter';

            // Outer glow
            ctx.shadowBlur = 20;
            ctx.shadowColor = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = 4;
            drawLightningBranch(ctx, start, end, 2, color); // Main bolt + branches

            // Inner core (white/bright)
            ctx.shadowBlur = 5;
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1.5;
            drawLightningBranch(ctx, start, end, 1, '#fff'); // Just main bolt

            ctx.restore();

            // Add sparks at collision point (end)
            for(let k=0; k<3; k++) {
                createSpark(end, {
                    x: (Math.random() - 0.5) * 10,
                    y: (Math.random() - 0.5) * 10
                }, color);
            }
        }

        // --- Main Loop ---

        Events.on(render, 'afterRender', function() {
            const ctx = render.context;

            // 0. Draw Fireworks
            updateAndDrawFireworks(ctx);

            // 1. Draw Sparks
            updateAndDrawSparks(ctx);

            // 2. Battery Details (draw on top of the body)
            const angle = battery.angle;
            const center = battery.position;

            // Terminals
            const tOffset = { x: batteryWidth * 0.35, y: -batteryHeight * 0.5 };
            const t1Pos = Vector.add(center, Vector.rotate({ x: -tOffset.x, y: tOffset.y }, angle)); // Left
            const t2Pos = Vector.add(center, Vector.rotate({ x: tOffset.x, y: tOffset.y }, angle));  // Right

            ctx.save();
            ctx.translate(center.x, center.y);
            ctx.rotate(angle);

            // Warning Symbol (Triangle)
            ctx.beginPath();
            ctx.moveTo(0, -15);
            ctx.lineTo(15, 10);
            ctx.lineTo(-15, 10);
            ctx.closePath();
            ctx.fillStyle = '#fc0';
            ctx.fill();
            // Lightning icon inside
            ctx.beginPath();
            ctx.moveTo(-2, 8);
            ctx.lineTo(4, 0);
            ctx.lineTo(0, 0);
            ctx.lineTo(3, -10);
            ctx.lineTo(-4, -2);
            ctx.lineTo(0, -2);
            ctx.closePath();
            ctx.fillStyle = '#000';
            ctx.fill();

            ctx.restore();

            // Draw Terminals circles
            ctx.fillStyle = '#ff4444';
            ctx.beginPath();
            ctx.arc(t1Pos.x, t1Pos.y, 8, 0, 2*Math.PI);
            ctx.fill();

            ctx.fillStyle = '#4444ff';
            ctx.beginPath();
            ctx.arc(t2Pos.x, t2Pos.y, 8, 0, 2*Math.PI);
            ctx.fill();


            // 3. Lightning Generation
            if (lightningEnabled) {
                // Logic: High voltage, wants to arc to closest conductive ground or mouse
                // Mouse is conductive
                const mousePos = mouse.position;
                const distMouse1 = Vector.magnitude(Vector.sub(mousePos, t1Pos));
                const distMouse2 = Vector.magnitude(Vector.sub(mousePos, t2Pos));

                const maxArcDist = 500; // Increased range

                // Arc between terminals (short circuit) if close enough?
                // No, they are fixed distance. Random arcing between them.
                if (Math.random() < 0.05) {
                    drawLightning(ctx, t1Pos, t2Pos, '#f0f'); // Plasma arc
                }

                // Arc to mouse
                if (distMouse1 < maxArcDist && Math.random() < 0.4) {
                     drawLightning(ctx, t1Pos, mousePos, '#fa0');
                }
                if (distMouse2 < maxArcDist && Math.random() < 0.4) {
                     drawLightning(ctx, t2Pos, mousePos, '#0af');
                }

                // Arc to Golems
                golems.forEach(golem => {
                    const gPos = golem.position;

                    // Soft ceiling logic: push down if too high
                    if (gPos.y < -50) {
                         Body.applyForce(golem, gPos, { x: 0, y: 1.0 * golem.mass * 0.002 }); // Downward push proportional to mass
                    }

                    const dist1 = Vector.magnitude(Vector.sub(gPos, t1Pos));
                    const dist2 = Vector.magnitude(Vector.sub(gPos, t2Pos));

                    if (dist1 < maxArcDist && Math.random() < 0.6) {
                        drawLightning(ctx, t1Pos, gPos, '#aaf');
                        // "Shock" effect: reduced force
                        Body.applyForce(golem, golem.position, { x: (Math.random()-0.5)*0.05, y: -0.05 });
                    }
                    if (dist2 < maxArcDist && Math.random() < 0.6) {
                        drawLightning(ctx, t2Pos, gPos, '#aaf');
                         Body.applyForce(golem, golem.position, { x: (Math.random()-0.5)*0.05, y: -0.05 });
                    }
                });

                // Arc to ground/walls
                // Cast a few rays out from terminals
                [t1Pos, t2Pos].forEach(startPos => {
                    if (Math.random() > 0.3) return; // Not every frame

                    const angleBase = angle - Math.PI/2; // pointing up relative to box
                    // Random angle
                    const rayAngle = angleBase + (Math.random() - 0.5) * Math.PI * 1.5;
                    const rayDir = { x: Math.cos(rayAngle), y: Math.sin(rayAngle) };

                    // Raycast
                    const collisions = Matter.Query.ray(
                        [ground, leftWall, rightWall],
                        startPos,
                        Vector.add(startPos, Vector.mult(rayDir, maxArcDist))
                    );

                    if (collisions.length > 0) {
                        // Find exact point? Matter.Query.ray returns bodies, not points directly in an easy way for all.
                        // Actually, Query.ray returns collisions with 'bodyA', 'bodyB', 'normal', 'tangent', etc.
                        // But it doesn't give the exact point of intersection easily without calculation or using Matter.Query.ray logic carefully.
                        // Let's approximate by creating a point at a distance.
                        // For better visuals, let's just use the ray end or the body position if close.

                        if (startPos.y > globalThis.innerHeight - 200) {
                            // Close to ground
                             const target = { x: startPos.x + (Math.random()-0.5)*100, y: globalThis.innerHeight - 30 };
                             drawLightning(ctx, startPos, target, '#bbf');
                        }
                    } else {
                        // Discharge into air (Corona discharge)
                        if (Math.random() < 0.1) {
                             const end = Vector.add(startPos, Vector.mult(rayDir, 50 + Math.random() * 100));
                             drawLightning(ctx, startPos, end, '#fff'); // Weaker color?
                        }
                    }
                });
            } else {
                // Keep soft ceiling logic active even if lightning is off
                golems.forEach(golem => {
                    const gPos = golem.position;
                    if (gPos.y < -50) {
                         Body.applyForce(golem, gPos, { x: 0, y: 1 * golem.mass * 0.002 });
                    }
                });
            }

        });

        // Run
        Render.run(render);
        const runner = Runner.create();
        Runner.run(runner, engine);

        // Handle Resize
        globalThis.addEventListener('resize', () => {
            render.canvas.width = globalThis.innerWidth;
            render.canvas.height = globalThis.innerHeight;

            Body.setPosition(ground, { x: globalThis.innerWidth / 2, y: globalThis.innerHeight + 50 });
            Body.setPosition(rightWall, { x: globalThis.innerWidth + 30, y: globalThis.innerHeight / 2 });
            Body.setVertices(ground, Bodies.rectangle(globalThis.innerWidth / 2, globalThis.innerHeight + 50, globalThis.innerWidth, 100).vertices);

            // Reposition stairs
            stairs.forEach((step, i) => {
                Body.setPosition(step, {
                    x: step.position.x, // Keep x constant
                    y: globalThis.innerHeight - (stepHeight/2) - (i * stepHeight)
                });
            });
        });

    </script>
</body>
</html>
