<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>ü¶ñ Monster-F√ºtterung - 1x1 lernen</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(to bottom, #87CEEB 0%, #98D8C8 100%);
            font-family: 'Comic Sans MS', cursive, Arial, sans-serif;
        }
        canvas {
            border: 4px solid #8B4513;
            background: linear-gradient(to bottom, #87CEEB 0%, #98D8C8 50%, #90EE90 100%);
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(139, 69, 19, 0.9);
            padding: 15px;
            border-radius: 10px;
            font-size: 16px;
        }
        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(139, 69, 19, 0.9);
            padding: 15px;
            border-radius: 10px;
            font-size: 20px;
            text-align: right;
        }
        #levelDisplay {
            font-size: 28px;
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 10px;
        }
        #scoreDisplay {
            font-size: 24px;
            color: #90EE90;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            background: #4CAF50;
            color: white;
            font-weight: bold;
            font-size: 16px;
        }
        button:hover {
            background: #45a049;
        }
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 215, 0, 0.95);
            color: #333;
            padding: 30px 50px;
            border-radius: 20px;
            font-size: 42px;
            font-weight: bold;
            display: none;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            z-index: 1000;
            text-align: center;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 18px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button onclick="resetGame()">üîÑ Neues Spiel (R)</button>
        <div style="margin-top: 10px; font-size: 14px;">Ziehe die Frucht zum Monster!</div>
    </div>
    <div id="stats">
        <div id="levelDisplay">Level 1: Einfach</div>
        <div id="scoreDisplay">‚≠ê Punkte: <span id="score">0</span></div>
        <div style="font-size: 16px; margin-top: 5px;">Richtig: <span id="correct">0</span> | Falsch: <span id="wrong">0</span></div>
    </div>

    <div id="instructions">Klicke auf die Frucht und ziehe sie zum hungrigen Monster! üçé‚û°Ô∏èü¶ñ</div>

    <div id="message"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.20.0/matter.min.js"></script>
    <script>
        // Matter.js setup
        const { Engine, Render, World, Bodies, Body, Events, Mouse, MouseConstraint } = Matter;
        const engine = Engine.create();
        engine.gravity.y = 0.3; // Reduced gravity so kids have time to think

        const canvas = document.createElement('canvas');
        canvas.width = 1000;
        canvas.height = 700;
        document.body.appendChild(canvas);

        const render = Render.create({
            canvas: canvas,
            engine: engine,
            options: {
                width: 1000,
                height: 700,
                wireframes: false,
                background: 'transparent'
            }
        });

        // Game state
        let monsters = [];
        let fruits = [];
        let particles = [];
        let currentLevel = 1;
        let score = 0;
        let correctAnswers = 0;
        let wrongAnswers = 0;

        // Audio context
        const audioContext = new (globalThis.AudioContext || globalThis.webkitAudioContext)();

        // Monster class
        class Monster {
            constructor(x, targetNumber, color, name) {
                this.x = x;
                this.y = 580;
                this.targetNumber = targetNumber;
                this.color = color;
                this.name = name;
                this.bellySize = 0;
                this.happiness = 0;
                this.mouthOpen = false;
                this.eyeSize = 1;
                this.bounceOffset = 0;
                this.bounceSpeed = 0.05;
            }

            update() {
                this.happiness = Math.max(0, this.happiness - 0.01);
                this.bellySize = Math.max(0, this.bellySize - 0.5);
                this.bounceOffset = Math.sin(Date.now() * this.bounceSpeed * 0.01) * 5;
            }

            draw(ctx) {
                const y = this.y + this.bounceOffset;

                ctx.save();
                ctx.translate(this.x, y);

                // Body
                const bodyGradient = ctx.createRadialGradient(0, -20, 10, 0, 0, 50);
                bodyGradient.addColorStop(0, this.lighten(this.color, 30));
                bodyGradient.addColorStop(1, this.color);

                ctx.fillStyle = bodyGradient;
                ctx.beginPath();
                ctx.ellipse(0, 0, 50, 60 + this.bellySize, 0, 0, Math.PI * 2);
                ctx.fill();

                // Belly
                ctx.fillStyle = this.lighten(this.color, 40);
                ctx.beginPath();
                ctx.ellipse(0, 10, 35, 45 + this.bellySize * 0.8, 0, 0, Math.PI * 2);
                ctx.fill();

                // Eyes
                const eyeY = -30;
                const eyeSpacing = 20;

                // Left eye
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(-eyeSpacing, eyeY, 12 * this.eyeSize, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(-eyeSpacing + (this.happiness > 0 ? 3 : 0), eyeY, 6, 0, Math.PI * 2);
                ctx.fill();

                // Right eye
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(eyeSpacing, eyeY, 12 * this.eyeSize, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(eyeSpacing + (this.happiness > 0 ? 3 : 0), eyeY, 6, 0, Math.PI * 2);
                ctx.fill();

                // Mouth
                if (this.mouthOpen) {
                    ctx.fillStyle = '#8B4513';
                    ctx.beginPath();
                    ctx.ellipse(0, -5, 15, 20, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.happiness > 0) {
                    // Happy smile
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, -5, 20, 0.2, Math.PI - 0.2);
                    ctx.stroke();
                } else {
                    // Neutral mouth
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, -5, 15, 0.3, Math.PI - 0.3);
                    ctx.stroke();
                }

                // Horns/Ears (depending on monster type)
                ctx.fillStyle = this.darken(this.color, 20);
                ctx.beginPath();
                ctx.moveTo(-40, -40);
                ctx.lineTo(-50, -60);
                ctx.lineTo(-35, -45);
                ctx.closePath();
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(40, -40);
                ctx.lineTo(50, -60);
                ctx.lineTo(35, -45);
                ctx.closePath();
                ctx.fill();

                // Arms
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 12;
                ctx.lineCap = 'round';

                // Left arm
                ctx.beginPath();
                ctx.moveTo(-45, 10);
                ctx.lineTo(-65, 30);
                ctx.stroke();

                // Right arm
                ctx.beginPath();
                ctx.moveTo(45, 10);
                ctx.lineTo(65, 30);
                ctx.stroke();

                // Legs
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 15;

                // Left leg
                ctx.beginPath();
                ctx.moveTo(-20, 60);
                ctx.lineTo(-20, 90);
                ctx.stroke();

                // Right leg
                ctx.beginPath();
                ctx.moveTo(20, 60);
                ctx.lineTo(20, 90);
                ctx.stroke();

                // Target number display
                ctx.fillStyle = 'white';
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 3;
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.strokeText(this.targetNumber, 0, 20);
                ctx.fillText(this.targetNumber, 0, 20);

                // Name tag
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(-40, -85, 80, 25);
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 14px Arial';
                ctx.fillText(this.name, 0, -72);

                ctx.restore();
            }

            feed() {
                this.happiness = 1;
                this.bellySize = 30;
                this.mouthOpen = false;
                this.eyeSize = 1.2;
                setTimeout(() => {
                    this.eyeSize = 1;
                }, 500);
            }

            reject() {
                this.eyeSize = 0.7;
                setTimeout(() => {
                    this.eyeSize = 1;
                }, 500);
            }

            openMouth() {
                this.mouthOpen = true;
            }

            closeMouth() {
                this.mouthOpen = false;
            }

            lighten(color, percent) {
                const num = parseInt(color.replace("#",""), 16);
                const amt = Math.round(2.55 * percent);
                const R = Math.min(255, (num >> 16) + amt);
                const G = Math.min(255, (num >> 8 & 0x00FF) + amt);
                const B = Math.min(255, (num & 0x0000FF) + amt);
                return `rgb(${R},${G},${B})`;
            }

            darken(color, percent) {
                const num = parseInt(color.replace("#",""), 16);
                const amt = Math.round(2.55 * percent);
                const R = Math.max(0, (num >> 16) - amt);
                const G = Math.max(0, (num >> 8 & 0x00FF) - amt);
                const B = Math.max(0, (num & 0x0000FF) - amt);
                return `rgb(${R},${G},${B})`;
            }
        }

        // Particle class
        class Particle {
            constructor(x, y, color, text = null) {
                this.x = x;
                this.y = y;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 6 + 2;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed - 3;
                this.gravity = 0.2;
                this.color = color;
                this.alpha = 1.0;
                this.fadeRate = 0.02;
                this.size = Math.random() * 8 + 5;
                this.text = text;
            }

            update() {
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
                this.alpha -= this.fadeRate;
            }

            draw(ctx) {
                if (this.alpha <= 0) return;

                ctx.save();
                ctx.globalAlpha = this.alpha;

                if (this.text) {
                    ctx.font = 'bold 24px Arial';
                    ctx.fillStyle = this.color;
                    ctx.textAlign = 'center';
                    ctx.fillText(this.text, this.x, this.y);
                } else {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }

            isDead() {
                return this.alpha <= 0;
            }
        }

        // Create fruit
        function createFruit(equation, answer) {
            const x = Math.random() * 600 + 200;
            const y = 100;
            const size = 25;

            const fruitTypes = ['üçé', 'üçä', 'üçå', 'üçá', 'üçì', 'üçë'];
            const fruitType = fruitTypes[Math.floor(Math.random() * fruitTypes.length)];

            const fruit = Bodies.circle(x, y, size, {
                restitution: 0.5,
                friction: 0.05,
                frictionAir: 0.06, // Added air friction to slow down falling fruits
                density: 0.001,
                render: { visible: false }
            });

            fruit.equation = equation;
            fruit.answer = answer;
            fruit.fruitType = fruitType;
            fruit.size = size;

            return fruit;
        }

        // Initialize monsters
        function initMonsters() {
            const monsterData = [
                { x: 150, number: 12, color: '#FF6B6B', name: 'Rudi' },
                { x: 350, number: 24, color: '#4ECDC4', name: 'Mia' },
                { x: 550, number: 18, color: '#FFE66D', name: 'Leo' },
                { x: 750, number: 30, color: '#95E1D3', name: 'Luna' }
            ];

            monsters = monsterData.map(data =>
                new Monster(data.x, data.number, data.color, data.name)
            );
        }

        // Spawn new fruits
        function spawnFruits() {
            // Clear existing fruits
            for (const f of fruits) {
                World.remove(engine.world, f);
            }
            fruits = [];

            // Create new fruits based on level
            const count = Math.min(3 + currentLevel, 6);

            for (let i = 0; i < count; i++) {
                // Pick random monster target
                const targetMonster = monsters[Math.floor(Math.random() * monsters.length)];
                const targetNumber = targetMonster.targetNumber;

                // Generate equation that equals target
                let a, b;
                const factors = [];
                for (let j = 1; j <= 10; j++) {
                    if (targetNumber % j === 0 && targetNumber / j <= 10) {
                        factors.push([j, targetNumber / j]);
                    }
                }

                if (factors.length > 0) {
                    const [factorA, factorB] = factors[Math.floor(Math.random() * factors.length)];
                    a = factorA;
                    b = factorB;
                } else {
                    // Fallback
                    a = Math.floor(Math.random() * 5) + 1;
                    b = Math.floor(Math.random() * 10) + 1;
                }

                const equation = `${a} √ó ${b}`;
                const answer = a * b;

                const fruit = createFruit(equation, answer);
                World.add(engine.world, fruit);
                fruits.push(fruit);
            }
        }

        // Check collision with monsters
        function checkMonsterCollision(fruit) {
            const fruitPos = fruit.position;

            for (const monster of monsters) {
                const dx = fruitPos.x - monster.x;
                const dy = fruitPos.y - monster.y;
                const distance = Math.hypot(dx, dy);

                if (distance < 60) {
                    // Collision detected
                    if (fruit.answer === monster.targetNumber) {
                        // Correct!
                        monster.feed();
                        correctAnswers++;
                        score += currentLevel * 10;
                        playSuccessSound();
                        playEatSound();

                        // Create particles
                        for (let i = 0; i < 20; i++) {
                            particles.push(new Particle(monster.x, monster.y - 30, '#FFD700'));
                        }
                        particles.push(new Particle(monster.x, monster.y - 80, '#FFD700', 'Mmmh! üòã'));

                        // Check level up
                        if (correctAnswers % 10 === 0 && currentLevel < 5) {
                            currentLevel++;
                            updateStats();
                            showMessage(`üéâ Level ${currentLevel}!<br>Mehr Fr√ºchte!`);
                        }
                    } else {
                        // Wrong!
                        monster.reject();
                        wrongAnswers++;
                        playErrorSound();

                        // Create particles
                        for (let i = 0; i < 10; i++) {
                            particles.push(new Particle(monster.x, monster.y - 30, '#FF6B6B'));
                        }
                        particles.push(new Particle(monster.x, monster.y - 80, '#FF6B6B', 'Nein! üòñ'));
                    }

                    // Remove fruit
                    World.remove(engine.world, fruit);
                    fruits = fruits.filter(f => f !== fruit);

                    updateStats();

                    // Spawn new fruits if all gone
                    if (fruits.length === 0) {
                        setTimeout(spawnFruits, 1000);
                    }

                    return true;
                }
            }

            return false;
        }

        // Show message
        function showMessage(text) {
            const msg = document.getElementById('message');
            msg.innerHTML = text;
            msg.style.display = 'block';
            setTimeout(() => {
                msg.style.display = 'none';
            }, 2000);
        }

        // Update stats
        function updateStats() {
            document.getElementById('levelDisplay').textContent = `Level ${currentLevel}`;
            document.getElementById('score').textContent = score;
            document.getElementById('correct').textContent = correctAnswers;
            document.getElementById('wrong').textContent = wrongAnswers;
        }

        // Sound effects
        function playSuccessSound() {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.connect(gain);
            gain.connect(audioContext.destination);

            osc.frequency.value = 523.25;
            osc.type = 'sine';
            gain.gain.setValueAtTime(0.2, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);

            osc.start(audioContext.currentTime);
            osc.stop(audioContext.currentTime + 0.3);
        }

        function playEatSound() {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.connect(gain);
            gain.connect(audioContext.destination);

            osc.frequency.value = 300;
            osc.type = 'square';
            gain.gain.setValueAtTime(0.15, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);

            osc.start(audioContext.currentTime);
            osc.stop(audioContext.currentTime + 0.15);
        }

        function playErrorSound() {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.connect(gain);
            gain.connect(audioContext.destination);

            osc.frequency.value = 150;
            osc.type = 'sawtooth';
            gain.gain.setValueAtTime(0.15, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);

            osc.start(audioContext.currentTime);
            osc.stop(audioContext.currentTime + 0.2);
        }

        // Custom rendering
        Events.on(render, 'afterRender', () => {
            const ctx = render.context;

            // Draw ground
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(0, 650, 1000, 50);

            // Draw grass
            ctx.fillStyle = '#228B22';
            for (let i = 0; i < 1000; i += 20) {
                ctx.fillRect(i, 645, 10, 10);
            }

            // Draw monsters
            for (const monster of monsters) {
                monster.update();
                monster.draw(ctx);
            }

            // Draw fruits
            for (const fruit of fruits) {
                const pos = fruit.position;
                const size = fruit.size;

                ctx.save();
                ctx.translate(pos.x, pos.y);
                ctx.rotate(fruit.angle);

                // Draw fruit emoji
                ctx.font = `${size * 2}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(fruit.fruitType, 0, 0);

                // Draw equation
                ctx.font = 'bold 16px Arial';
                ctx.fillStyle = 'white';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.strokeText(fruit.equation, 0, 0);
                ctx.fillText(fruit.equation, 0, 0);

                ctx.restore();
            }

            // Draw particles
            for (const particle of particles) {
                particle.draw(ctx);
            }
        });

        // Update logic
        Events.on(engine, 'beforeUpdate', () => {
            // Update particles
            for (const particle of particles) {
                particle.update();
            }
            particles = particles.filter(p => !p.isDead());

            // Check fruit collisions with monsters
            for (const fruit of fruits) {
                checkMonsterCollision(fruit);

                // Remove fruits that fall off screen
                if (fruit.position.y > 700) {
                    World.remove(engine.world, fruit);
                    fruits = fruits.filter(f => f !== fruit);

                    if (fruits.length === 0) {
                        setTimeout(spawnFruits, 500);
                    }
                }
            }

            // Check if fruit is near monster (for mouth opening)
            for (const m of monsters) {
                m.closeMouth();
            }
            for (const fruit of fruits) {
                for (const monster of monsters) {
                    const dx = fruit.position.x - monster.x;
                    const dy = fruit.position.y - monster.y;
                    const distance = Math.hypot(dx, dy);

                    if (distance < 100) {
                        monster.openMouth();
                    }
                }
            }
        });

        // Mouse interaction for dragging
        const mouse = Mouse.create(canvas);
        const mouseConstraint = MouseConstraint.create(engine, {
            mouse: mouse,
            constraint: {
                stiffness: 0.2,
                render: { visible: false }
            }
        });

        World.add(engine.world, mouseConstraint);

        // Enable audio on first interaction
        canvas.addEventListener('mousedown', () => {
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }, { once: true });

        // Reset game
        function resetGame() {
            currentLevel = 1;
            score = 0;
            correctAnswers = 0;
            wrongAnswers = 0;
            updateStats();
            spawnFruits();
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'r' || e.key === 'R') {
                resetGame();
            }
        });

        // Initialize game
        initMonsters();
        spawnFruits();
        updateStats();

        // Start physics
        Render.run(render);
        const runner = Matter.Runner.create();
        Matter.Runner.run(runner, engine);

        console.log('ü¶ñ Monster-F√ºtterung ready!');
    </script>
</body>
</html>
